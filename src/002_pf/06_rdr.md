## [*Open***BSD**](https://www.openbsd.org/index.html) <span style="color: red;">PF - 流量重定向（端口转发）</span>

---

- <a href="#intro">简介</a>
- <a href="#security">安全影响</a>
- <a href="#reflect">重定向和反射</a>
    - <a href="#splitdns">水平分割 DNS</a>
    - <a href="#sepnet">将服务器移至单独的本地网络</a>
    - <a href="#tcpproxy">TCP 代理</a>
    - <a href="#rdrnat">RDR-TO 和 NAT-TO 组合</a>

---

<h2 id="intro">简介</h2>

重定向允许将传入流量发送到 NAT 网关后面的机器。

让我们看一个例子：

```text
pass in on egress proto tcp from any to any port 80 rdr-to 192.168.1.20
```

此行将 TCP 端口 80（Web 服务器）流量重定向到网络内部 192.168.1.20 处的机器。因此，即使 192.168.1.20 位于网关后面且在网络内部，外部世界也可以访问它。

上述 `rdr` 行中的 `from any to any` 部分非常有用。如果知道应该访问端口 80 上的 Web 服务器的地址或子网，可以在此处进行限制：

```text
pass in on egress proto tcp from 203.0.113.0/24 to any port 80 rdr-to 192.168.1.20
```

这将仅重定向指定的子网。可以将不同的传入主机重定向到网关后面的不同机器。

例如，只要知道远程站点用户将从中连接的 IP 地址，他们就可以使用网关上的相同端口和 IP 地址访问自己的台式计算机。

```text
pass in on egress proto tcp from 203.0.113.14 to any port 80 rdr-to 192.168.1.20
pass in on egress proto tcp from 198.51.100.89 to any port 80 rdr-to 192.168.1.22
pass in on egress proto tcp from 198.51.100.178 to any port 80 rdr-to 192.168.1.23
```

也可以在同一规则中重定向一系列端口：

```text
pass in on egress proto tcp from any to any port 5000:5500 \
   rdr-to 192.168.1.20
pass in on egress proto tcp from any to any port 5000:5500 \
   rdr-to 192.168.1.20 port 6000
pass in on egress proto tcp from any to any port 5000:5500 \
   rdr-to 192.168.1.20 port 7000:*
```

这些示例显示端口 5000 到 5500（含）被重定向到 192.168.1.20。
在规则 #1 中，端口 5000 重定向到 5000，5001 到 5001，依此类推。
在规则 #2 中，整个端口范围重定向到端口 6000。
在规则 #3 中，端口 5000 重定向到 7000，5001 到 7001，依此类推。

<h2 id="security">安全影响</h2>

重定向确实有安全影响。在防火墙上打孔以允许流量进入内部受保护网络可能会使内部机器受到损害。如果流量转发到内部 Web 服务器，并且在 Web 服务器守护进程中发现漏洞，则该机器可能会被互联网上的入侵者攻陷。从那里，入侵者就有了通往内部网络的入口。

可以通过将外部访问的系统严格限制在单独的网络上来最大限度地降低这些风险。该网络通常称为非军事区 (DMZ) 或专用服务网络 (PSN)。这样，如果 Web 服务器受到损害，可以通过仔细过滤进出它的流量，将影响限制在 DMZ/PSN 网络内。

<h2 id="reflect">重定向和反射</h2>

通常，重定向规则用于将来自互联网的传入连接转发到内部网络或 LAN 中具有私有地址的本地服务器，如：

```text
server = 192.168.1.40
pass in on egress proto tcp from any to egress port 80 rdr-to $server port 80
```

但是，当从 LAN 上的客户端测试重定向规则时，它不起作用。原因是重定向规则仅适用于通过指定接口（示例中的 egress，即外部接口）的数据包。然而，从 LAN 上的主机连接到防火墙的外部地址并不意味着数据包实际上会通过其外部接口。防火墙上的 TCP/IP 堆栈将传入数据包的目标地址与其自己的地址和别名进行比较，并在它们通过内部接口后立即检测到对自身的连接。此类数据包实际上并未通过外部接口，并且堆栈也不会以任何方式模拟此类通过。因此，PF 永远不会在外部接口上看到这些数据包，并且指定外部接口的重定向规则不适用。

为内部接口添加第二个重定向规则也不会产生预期的效果。当本地客户端连接到防火墙的外部地址时，TCP 握手的初始数据包通过内部接口到达防火墙。重定向规则确实适用，并且目标地址被替换为内部服务器的地址。数据包通过内部接口转发回去并到达内部服务器。但是源地址尚未转换，仍然包含本地客户端的地址，因此服务器直接将其回复发送给客户端。防火墙永远看不到回复，也没有机会正确反转转换。客户端收到来自它从未预期的源的回复并将其丢弃。然后 TCP 握手失败，无法建立连接。

尽管如此，通常希望 LAN 上的客户端连接到与外部客户端相同的内部服务器，并且透明地进行连接。这个问题有几种解决方案：

<h3 id="splitdns">水平分割 DNS</h3>

可以配置 DNS 服务器以不同于外部查询的方式回答来自本地主机的查询，以便本地客户端在名称解析期间将接收内部服务器的地址。然后它们将直接连接到本地服务器，防火墙根本不参与。这减少了本地流量，因为数据包不必通过防火墙发送。

<h3 id="sepnet">将服务器移至单独的本地网络</h3>

向防火墙添加额外的网络接口并将本地服务器从客户端网络移动到专用网络 (DMZ) 允许以与重定向外部连接相同的方式重定向来自本地客户端的连接。使用单独的网络有几个优点，包括通过将服务器与其余本地主机隔离来提高安全性。如果服务器（可从互联网访问）受到损害，它无法直接访问其他本地主机，因为所有连接都必须通过防火墙。

<h3 id="tcpproxy">TCP 代理</h3>

可以在防火墙上设置通用 TCP 代理，要么监听要转发的端口，要么将内部接口上的连接重定向到它正在监听的端口。当本地客户端连接到防火墙时，代理接受连接，建立到内部服务器的第二个连接，并在两个连接之间转发数据。

<h3 id="rdrnat">RDR-TO 和 NAT-TO 组合</h3>

通过在内部接口上添加额外的 NAT 规则，可以实现上述缺少的源地址转换。

```text
pass in on $int_if proto tcp from $int_net to egress port 80 rdr-to $server
pass out on $int_if proto tcp to $server port 80 received-on $int_if nat-to $int_if
```

这将导致来自客户端的初始数据包在通过内部接口转发回去时再次被转换，将客户端的源地址替换为防火墙的内部地址。内部服务器将回复防火墙，防火墙在转发给本地客户端时可以反转 NAT 和 RDR 转换。这种结构相当复杂，因为它为每个反射连接创建两个单独的状态。必须小心防止 NAT 规则应用于其他流量，例如源自外部主机（通过其他重定向）或防火墙本身的连接。请注意，上面的 `rdr-to` 规则将导致 TCP/IP 堆栈看到到达内部接口的数据包，其目标地址位于内部网络内。
